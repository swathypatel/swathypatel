

- To pick the combinations:
    - 8 pant and 10 shirts are present:
    to choose a shirt and pant = 10 * 8 ways.

- To arrange a, b, c, d in straight line :
    - a , b, c, d
    - a , c, d, b
    - d, c, b, a .... 4! = 4 * 3 * 2 * 1 = 24
    Number of PERMUTATIONS to arrange n objects is = n!

    If repetition is allowed then
        - a, a, a, a
        - b, b, b, b
        ......        4 ^ 4 =
        Number of ARRAGEMENTs to to arrange n objects is = n ^ n

    - The number of ways of seating 6 students in a row of 4 chairs
        6 * 5 * 4 * 3 = 360

    - A traveling salesman needs to travel to n cities to sell his products.
        number of ways he should travel to pick the shortest 1.
        n!

- Decrease and conquer and divide and conquer are 2 strategies used in recursion.

    -Factorial uses decrease and conquer
    - Time complexity = O(n)
    def fact(n):
        if n == 0:
            return 1
        else:
            return n * fact(n - 1)

    -iterative way : Time complexity = O(n)
    def fact(n):
        result = 1
        for i in range(1, n + 1):
            result = i * result
        return result


- Recursive loop of faith:
    - Focus on single level of recursion.
    - Give child funtion simpler than original values.
    - Always have a base condition.


- n = n + (n-1) + (n-2) .... 1
  n = n/2 + n /2    --> This reduces the time complexity than above.

- memoization: caching
               for speeding up the execution, the results of some values are stored so that they can be used again.

    additive sequence: In any series, keep first 2 values, remaining values are generated by adding n-1 and n-2 values.
    4, 6, 10, 16, ...
    3, 5, 8, 13 ..
    If we keep fibonacci series in binary tree format, top down is memoization
    bottom up is dynamic programming

- f(n) = f(n-1) + f(n-3), in this 3 bases are required.

- Recursive solution may NOT be exponential all the time.


- Permutations(order matters): example: p, q, r, s number of of ways to group is permutation.
    has 2 types 1) repetitions allowed 2) repetitions not allowed.
- Combinations : example: p,q,r,s out of these letters, choosing 3 letters is a combination.
    repetition not allowed and order not important.
    C(n, k) = C(n-1, k) + C(n - 1, k - 1)
    C(n, k) = n!/ (n - k)! * k!


Decrease and conquer: Mostly go with the iterative approach.
Divide and conquer: Mostly go with the recursive approach.

Generic recursion :

def helper(s, i, slate, results):
    #base case
    if subproblem.isempty or partial_sol.issolved:
        results.append(slate)
        return
    # recursive case
    choices = subproblem.getchoices()
    for i, choice in enum(choices):
        help(subproblem, index, partial_soln + choice, results)

def overall_function(s):
   helper(s, 0, slate, results)


Backtracking : Sometimes a recursive problem has branches that wont give the valid solutions.
               If you determine this early on in branch, you shouldn't keep recursing to all leaf cases from where you are.
               This leads to exponnential improvement in combinatorial search.

result[:]
    In most base cases we have [:] to list because is list is mutating and it expands and shrinks.
    When we get the right values, we take the copy of list.
    Hence we add [:] to copy that list.

def rec():
    #base condition
        result.append(1)
        return
    #recursive condition

    return result # if the recursive is not hit and function returns from base condition, then this return will not hit.
    # if recursive condition is hit then only this return makes sense.

Manager <--> subordinate

2 # vertex
- # edge

In dfs , many problems have top down approach which is pre order in broad way.
        Other problems have bottom approach which is post order in broad way.

Head recursion:
{
    recursive call
    //work to be done

}

Tail recursion:
{
    //work to be done
    recursive call
}